# -*- coding: utf-8 -*-
"""python-final.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12_pBgxwpZUTyXPySW9fcxQP0Sj3Joh2B
"""

from google.colab import drive
drive.mount('/content/drive')

!pip install biopython
import Bio
print (Bio.__version__)

from Bio import SeqIO
record = list(SeqIO.parse("/content/drive/MyDrive/Portfolio/course/dna.example.fasta", "fasta"))
len(record)

try:
  f = open("/content/drive/MyDrive/Portfolio/course/dna.example.fasta")
  print ("File imported")
except IOError:
  print ("File does not exist")

seqs = {}
for line in f: # discard new lines at the end
  line = line.rstrip()
  if line[0] =='>': # identify headers
    words = line.split()
    name = words[0][1:]
    seqs[name] = ''
  else:
    seqs[name] = seqs[name] + line

print ('There are', len(seqs), 'records in this file')

for name,seq in seqs.items():
    print(name,'has length of', len(seq), ', complete sequence:', seq)

i = 0
j = 0
largest_seq = list(seqs.values())[i]
for i in range (0,len(seqs)-1):
  if len(largest_seq) < len(list(seqs.values())[i+1]):
     largest_seq = list(seqs.values())[i+1]
     j=i+1
  i=i+1
print('Complete sequence of the longest record is', largest_seq)
print('Longest record is at index number', j)
print('Length of the Longest record is', (len(largest_seq)))
print('Genome ID of the longest record is', list(seqs)[j])

i = 0
count = 0
for i in range (0,len(seqs)-1):
  if len(list(seqs.values())[i]) == len(largest_seq):
    count=count+1
  i=i+1

print('The dataset has', count, 'record(s) with the length', (len(largest_seq)),'(longest)')

m = 0
n = 0
shortest_seq = list(seqs.values())[m]
for m in range (0,len(seqs)-1):
  if len(shortest_seq) > len(list(seqs.values())[m+1]):
     shortest_seq = list(seqs.values())[m+1]
     n=m+1
  m=m+1
print('Complete sequence of the shortest record is', shortest_seq)
print('Shortest record is at index number', n)
print('Length of the shortest record is', (len(shortest_seq)))
print('Genome ID of the shortest record is', list(seqs)[n])

n = 0
count = 0
for n in range (0,len(seqs)-1):
  if len(list(seqs.values())[n]) == len(shortest_seq):
    count=count+1
  n=n+1

print('The dataset has', count, 'record(s) with the length', (len(shortest_seq)),'(shortest)')

def start_codon_at(seq, reading_frame):
  j=[]
  start_codon = ["ATG"]
  start_codon_found = False
  for i in range(reading_frame-1,len(seq),3):
    codon = seq[i:i+3]
    if codon in start_codon:
      start_codon_found = True
      j.append(i)
  return j

def stop_codon_at(seq, reading_frame):
  j=[]
  stop_codon = ["TAA","TAG","TGA"]
  stop_codon_found = False
  for i in range(reading_frame-1,len(seq),3):
    codon = seq[i:i+3]
    if codon in stop_codon:
      stop_codon_found = True
      j.append(i)
  return j

i = 0
j = 0
global_longest_ORF = 0
for i in range (0,len(seqs)):
  have_ORF = False
  local_longest_ORF = 0
  for rf in range (1,4):
    srt = start_codon_at(list(seqs.values())[i],rf)
    stp = stop_codon_at(list(seqs.values())[i],rf)
    if len(srt) > 0 and len(stp) > 0:
        have_ORF = True
        ORF_length = stp[-1] + 2 - srt[0]
        if ORF_length > local_longest_ORF:
          starting_point = srt[0]
          local_longest_ORF = ORF_length
        if ORF_length > global_longest_ORF:
          global_longest_ORF = ORF_length
          j=i
    rf=rf+1
  if have_ORF == True:
    print(list(seqs)[i],'has the longest ORF of', local_longest_ORF,'start at position',starting_point)
  else:
    print(list(seqs)[i],'has no valid ORF')
  i=i+1

print('The longest ORF in the dataset has the length of', global_longest_ORF, 'within the sequence ID', list(seqs)[j])

def break_seq (seq,size):
  break_codons_string = []
  reading_frame = 0
  for reading_frame in range(0,3):
    string_by_rf =[]
    delta = len(seq)%3
    #for z in range(0, 3-delta):
    #  seq+='N'
    #  z=z+1
    i = reading_frame
    stop_point = len(seq) - len(seq)%size
    for i in range(reading_frame,stop_point,size):
      codon = seq[i:i+size]
      string_by_rf.append(codon)
    break_codons_string.append(string_by_rf)
  return break_codons_string

print(break_seq(list(seqs.values())[1],6))
for l in break_seq(list(seqs.values())[1],6):
    print(*[e[0] for e in l])
import numpy as np
substrings_np = np.array(break_seq(list(seqs.values())[1],6))
print (substrings_np[0,:])

s = 5
void = ['N','NN','NNN']
global_repeated_substrings= []
global_repeated_count = []
for i in range (0,len(seqs)):

  reading_rf1 = np.array(break_seq(list(seqs.values())[i],s))[0,:]
  reading_rf2 = np.array(break_seq(list(seqs.values())[i],s))[1,:]
  reading_rf3 = np.array(break_seq(list(seqs.values())[i],s))[2,:]
  j = 0
  repeated_substrings = []
  repeated_count = []
  for j in range(0,len(reading_rf1)):
    if reading_rf1[j] not in void and reading_rf1[j] in reading_rf2:
      if reading_rf1[j] in repeated_substrings:
        for k in range(0, len(repeated_substrings)):
          if repeated_substrings[k] == reading_rf1[j]:
            index = k
          k=k+1
        repeated_count[index]=repeated_count[index]+1
      else:
        repeated_substrings.append(reading_rf1[j])
        repeated_count.append(1)

  j=0
  for j in range(0,len(reading_rf1)):
    if reading_rf1[j] not in void and reading_rf1[j] in reading_rf3:
      if reading_rf1[j] in repeated_substrings:
        for k in range(0, len(repeated_substrings)):
          if repeated_substrings[k] == reading_rf1[j]:
            index = k
        repeated_count[index]=repeated_count[index]+1
      else:
        repeated_substrings.append(reading_rf1[j])
        repeated_count.append(1)

  j=0
  for j in range(0,len(reading_rf2)):
    if reading_rf2[j] not in void and reading_rf2[j] in reading_rf3:
      if reading_rf2[j] in repeated_substrings:
        for k in range(0, len(repeated_substrings)):
          if repeated_substrings[k] == reading_rf2[j]:
            index = k
          k=k+1
        repeated_count[index]=repeated_count[index]+1
      else:
        repeated_substrings.append(reading_rf2[j])
        repeated_count.append(1)
  print(list(seqs)[i], ': ', end="")
  if repeated_substrings == []:
    print('no repeated substrings of size', s)
  else:
    max_index = 0
    list_len = len(repeated_count)
    for index in range(list_len):
      if repeated_count[index] > repeated_count[max_index]:
        max_index = index
    print("the most frequent repeat of length", s ,':', repeated_substrings[max_index], 'with', repeated_count[max_index],'times.')
    for x in range (0,len(repeated_substrings)):
      if repeated_substrings[x] in global_repeated_substrings:
        for y in range (0,len(global_repeated_substrings)):
          if global_repeated_substrings[y] == repeated_substrings[x]:
            index2 = y
        global_repeated_count[index2]=global_repeated_count[index2]+repeated_count[x]
      else:
            global_repeated_substrings.append(repeated_substrings[x])
            global_repeated_count.append(1)
      print (repeated_substrings[x], 'repeats',repeated_count[x],'time(s)', end="")
      if x < len(repeated_substrings)-1:
        print (', ', end="")
      else:
        print('.')
print('In this dataset, for substring with length', s)
for p in range (0,len(global_repeated_substrings)):
  print(global_repeated_substrings[p], 'repeats', global_repeated_count[p], 'time(s)' ,end="")
  if x < len(global_repeated_substrings)-1:
    print (', ', end="")
  else:
    print('.')

max_index = 0
list_len = len(global_repeated_count)
for index in range(list_len):
    if global_repeated_count[index] > global_repeated_count[max_index]:
        max_index = index
print("The most frequent repeat of length",s ,'in the dataset is', global_repeated_substrings[max_index], 'with', global_repeated_count[max_index],'times.')